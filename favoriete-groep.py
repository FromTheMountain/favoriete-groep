from sys import argv
from itertools import combinations
from math import log2, floor
from functools import reduce

class Group:
    def __init__(self, open_file = None):
        if open_file is not None:
            # We can use open_file as an iterable, where we iterate over each
            # line.
            elem_names = next(open_file).split()

            self.name_elem_map = dict()
            self.elems = list()

            for i, g in enumerate(elem_names):
                elem = self.GroupElement(self, i, g)
                self.name_elem_map[g] = elem
                self.elems.append(elem)

            self.order = len(self.elems)

            self.group_matrix = [[None for _ in self.elems] \
                for _ in self.elems]

            for i, l in enumerate(open_file):
                self.group_matrix[i] = \
                    [self.name_elem_map[x] for x in l.split()[1:]]

            self.identity = self.find_identity()
        else:
            self.elems = list()
            self.group_matrix = [[]]
            self.name_elem_map = dict()
            self.identity = None

    def element(self, name):
        """Return a reference to the group element named name."""
        return self.name_elem_map[name]

    def group_operation(self, first, second):
        return self.group_matrix[first.index][second.index]

    def group_order(self):
        return len(self.elems)

    def find_identity(self):
        for i in self.elems:
            if all(i * x == x * i == x for x in self.elems):
                return i

        raise Exception("The group does not seem to have an identity!")

    def get_identity(self):
        if self.identity is None:
            self.identity = self.find_identity()

        return self.identity

    def inverse(self, elem):
        for i in self.elems:
            if elem * i == i * elem == self.identity:
                return i

        raise Exception("This element does not seem to have an inverse!")

    def subgroup_by_generators(self, generators):
        """
        Return the list of elements in the subgroup generated by the elements
        in generators.
        """
        s = list(generators)
        i = 0
        while (i < len(s)):
            for j in range(i + 1):
                if all(s[i] * s[j] != x for x in s):
                    s.append(s[i] * s[j])
                if all(s[j] * s[i] != x for x in s):
                    s.append(s[j] * s[i])
            i += 1

        return sorted(s, key = lambda x: x.index)

    def left_coset(self, H, g):
        return sorted([g * x for x in H], key = lambda x: x.index)

    def right_coset(self, H, g):
        return sorted([x * g for x in H], key = lambda x: x.index)

    def left_cosets(self, H):
        cosets = list()

        for i in self.elems:
            new_coset = self.left_coset(H, i)

            if all(new_coset != x for x in cosets):
                cosets.append(new_coset)

        cosets.sort(key = lambda x: x[0].index)
        return cosets

    def right_cosets(self, H):
        cosets = list()

        for i in self.elems:
            new_coset = self.right_coset(H, i)

            if all(new_coset != x for x in cosets):
                cosets.append(new_coset)

        cosets.sort(key = lambda x: x[0].index)
        return cosets

    class GroupElement:
        def __init__(self, group, index, name):
            self.group = group
            self.index = index
            self.name = name

        def __mul__(self, other):
            return self.group.group_operation(self, other)

        def __pow__(self, other):
            to_multiply = self.group.inverse(self) if other < 0 else self
            res = self.group.get_identity()

            for _ in range(abs(other)):
                res *= to_multiply

            return res

        def __eq__(self, other):
            return self.group == other.group and self.index == other.index

        def __str__(self):
            return str(self.name)

        def __repr__(self):
            return str(self)

        def __hash__(self):
            return hash(repr(self))

def group_test():
    """
    Function to test some basic group class functionality.
    """
    g = Group()
    one = Group.GroupElement(g, 0, 1)
    negative_one = Group.GroupElement(g, 1, -1)
    g.elems = [one, negative_one]
    g.group_matrix = [[one, negative_one], [negative_one, one]]
    g.name_elem_map = {1: one, -1: negative_one}

    a = g.element(-1)
    b = g.element(-1)
    print(a * b)

if __name__ == "__main__":
    if len(argv) != 2:
        print("Geef de bestandsnaam als enige command line argument.")
        exit()

    file_name = argv[1]

    with open(file_name, "r") as group_file:
        G = Group(group_file)

    # Hoofdstuk 1
    print("Orde: %s" % (G.order))
    print("Identiteit: %s" % G.get_identity())
    print("Inversen van eerste 10 elementen: ", end = "")
    print([x**(-1) for x in G.elems[:10]])

    # Hoofdstuk 2
    subgroups = []
    print("Ondergroepen: ")

    # TODO: come up with a better way to generate subgroups.
    for i in range(1, 3):
        for j in combinations(G.elems, i):
            # This is just a temporary hack to make generation faster. We might
            # miss out on some subgroups because of it.
            if any(all(y in x for y in j) for x in subgroups):
                continue

            new_subgroup = G.subgroup_by_generators(j)
            subgroups.append(new_subgroup)

    print(list(filter(lambda x: len(x) > 1, subgroups))[:3])

    # Hoofdstuk 3
    print("Ondergroep met verschillende linker- en rechternevenklassen: ")
    for i in subgroups:
        left, right = G.left_cosets(i), G.right_cosets(i)

        if left != right:
            print(i)
            print(left)
            print(right)
            print("Index van bovenstaande ondergroep: %d" \
                % (G.order / len(i)))
            break

    # Hoofdstuk 4
    print("Normaaldelers: ")
    for i in subgroups:
        if G.left_cosets(i) == G.right_cosets(i):
            print(i)

    print("Centrum: ")
    print([x for x in G.elems if all(x * y == y * x for y in G.elems)])

    print("Commutatoren: ")
    commutators = set()
    for x in G.elems:
        for y in G.elems:
            commutators.add(x**(-1) * y**(-1) * x * y)

    print(sorted(commutators, key = lambda x: x.index))

    # Hoofdstuk 5 - 8 zijn WIP.
